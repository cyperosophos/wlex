from quiver import Quiver;
from posetoid import Posetoid, Congruence;

spec Category;
type Q <- Quiver;
type P <- Posetoid with
    Q = Q.Q0;
type S <- Congruence with
    S.P.Q = Q.Q1;
type Obj := P.El;
type Mor := P.Rel;
type Eq := S.Eq;
fn eq := S.eq;
fn source := P.source;
fn target := P.target;
type Composable := P.Path;
fn identity := P.ref;
fn compose := P.trans;

fn left_identity_law := (compose @ (identity @ target, $), $) @ Mor -> eq;
fn right_identity_law := (compose @ ($, identity @ source), $) @ Mor -> eq;
fn associativity := (
    compose @ ($f, compose @ ($g, $h)),
    compose @ (compose @ ($f, $g), $h),
) @ (
    Composable,
    (g, h): Composable,
) -> eq;

type ComposableEq := (
    d, e: Eq,
    source @ S.source @ $d == target @ S.target @ $e,
);

fn compose_eq: compose! @ !(S.source, S.target) @ ComposableEq -> eq;
# (S.source, S.target) @ ComposableEq is ambiguous
# it can mean ((s d, s e), (t d, t e)) or
# [(s, t), (s, t)] (d, e) i.e. ((s d, t d), (s e, t e))
# The first one is ([s, s], [t, t]) (d, e).
# With compose, one may try to resolve the ambiguity based on the
# type of the args, but this makes the actual meaning more implicit.
# Notice that [_, _] is the diagonal functor (or List functor, i.e. map).
# Transpose of m := ((a, b), (c, d))
# (($0 $0, $1 $0), ($0 $1, $1, $1)) = (0, 1)! (0, 1) = $
# (($0 $0, $0 $1), ($1 $0, $1, $1)) = (0!, 1!) (0, 1) = !(0, 1) # is this `= !$` ?
